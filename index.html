
<style type="text/css">
	body {
		font-family: "Helvetica Neue", Arial, Helvetica, sans-serif;
	}
	canvas {
		outline: none;
		border: 2px solid #000;
	}
	#score {
		font-weight: bold;
		color: #ed145b;
	}
</style>
<canvas id="canvas" width="200" height="200"></canvas>
<img src="mandrill.png">
<p>Score: <span id = "score">0</span></p>
<script src="processing-1.4.1.js"></script>
<script src="http://cdnjs.cloudflare.com/ajax/libs/dat-gui/0.5/dat.gui.min.js"></script>
<script>
var d = 200;
var BREED = .05;
var ATTRACTOR_RADIUS = 30;
var ATTRACT = 0.1;
var REPEL = -0.5;
var CHILD_AGE = 100;
var DEATH_AGE = 0;
var ATTRACTOR_DEATH_AGE = 10000;
var LAST_BREED = 3000;
var LAST_MOVE = 30;
var INITIAL_AGENTS = .005;
var DRAW_ATTRACTORS = true;
var ATTRACTOR_MODE = ATTRACT;
var grid = [];
var agents = [];
var attractors = [];

var imageData;
var scoreSpan = document.getElementById("score");

var setupGUI = function(parent) {
	var gui = new dat.GUI();
	gui.add(parent, "BREED", 0, 1);
	gui.add(parent, "ATTRACTOR_RADIUS", 10, 120);
	gui.add(parent, "ATTRACT", 0, 5);
	gui.add(parent, "REPEL", -5, 0);
	gui.add(parent, "CHILD_AGE", 5, 1000);
	gui.add(parent, "DEATH_AGE", 0, 20000);
	gui.add(parent, "ATTRACTOR_DEATH_AGE", 0, 20000);
	gui.add(parent, "LAST_BREED", 100, 3000);
	gui.add(parent, "LAST_MOVE", 20, 100);
	gui.add(parent, "DRAW_ATTRACTORS");
}

window.onload = function() {
	setupGUI(this);
	var sketch = new Processing("canvas");

	with(sketch) {

	var loadedImage = loadImage("mandrill.png");
	loadedImage.loadPixels();
	imageData = image.pixels;
	var directions = [
		{ x: -1, y: -1 },
		{ x: 0, y: -1 },
		{ x: 1, y: -1 },

		{ x: -1, y: 0 },
		//{ x: 0, y: 0 },
		{ x: 1, y: 0 },

		{ x: -1, y: 1 },
		{ x: 0, y: 1 },
		{ x: 1, y: 1 }
	];

	var atPixel = function(x, y) {
		return grid[(x * width) + y];
	};

	var atGrid = function(obj) {
		var startX = obj.x - floor(obj.width / 2);
		var endX = obj.x + floor(obj.width / 2);
		var startY = obj.y - floor(obj.height / 2);
		var endY = obj.y + floor(obj.height / 2);

		for (var x = startX; x <= endX; x++) {
			for (var y = startY; y <= endY; y++) {
				var pos = (x * width) + y;
				if (grid[pos] && grid[pos] !== obj) {
					return grid[pos];
				}
			}
		}

		return false;
	};

	var addGrid = function(obj) {
		var startX = obj.x - floor(obj.width / 2);
		var endX = obj.x + floor(obj.width / 2);
		var startY = obj.y - floor(obj.height / 2);
		var endY = obj.y + floor(obj.height / 2);

		for (var x = startX; x <= endX; x++) {
			for (var y = startY; y <= endY; y++) {
				var pos = (x * width) + y;
				grid[pos] = obj;
			}
		}
	};

	var removeGrid = function(obj, x, y) {
		x = x || obj.x;
		y = y || obj.y
		var startX = x - floor(obj.width / 2);
		var endX = x + floor(obj.width / 2);
		var startY = y - floor(obj.height / 2);
		var endY = y + floor(obj.height / 2)

		for (var x = startX; x <= endX; x++) {
			for (var y = startY; y <= endY; y++) {
				var pos = (x * width) + y;
				if (grid[pos] === obj) {
					grid[pos] = null;
				}
			}
		}
	};

	var Agent = function(color, x, y) {
		this.color = color;
		this.x = x;
		this.y = y;
		this.age = 0;
		this.lastBreed = 0;
		this.lastMove = 0;
		this.dead = false;

		if (!atPixel(x, y)) {
			addGrid(this);
			agents.push(this);
		}
	};

	Agent.prototype = {
		width: 1,
		height: 1,

		isChild: function() {
			return this.age < CHILD_AGE;
		},

		isDead: function() {
			return this.dead || DEATH_AGE > 0 && this.age > DEATH_AGE;
		},

		isInfertile: function() {
			return LAST_BREED > 0 && this.lastBreed > LAST_BREED;
		},

		isStagnant: function() {
			return LAST_MOVE > 0 && this.lastMove > LAST_MOVE;
		},

		kill: function() {
			this.dead = true;

			// Remove agent from the list
			var pos = agents.indexOf(this);
			agents.splice(pos, 1);
		},

		move: function() {
			var dir = null;

			if (this.attractDelay > 0) {
				dir = directions[Math.floor(Math.random() * directions.length)];
			} else if (this.weightCache) {
				dir = this.getDirOnWeight(this.weightCache);
			} else {
				dir = this.attract();
			}

			var x = this.x + dir.x;
			var y = this.y + dir.y;
			//this.x += dir.x; // * (floor(this.width / 2) || 1);
			//this.y += dir.y; // * (floor(this.height / 2) || 1);

			if (x < 0) {
				x += width;
			} else if (x > width) {
				x -= width;
			}

			if (y < 0) {
				y += height;
			} else if (y > height) {
				y -= height;
			}

			var obj = atPixel(x, y);

			if (!obj) {
				removeGrid(this);
				this.x = x;
				this.y = y;
				addGrid(this);
				this.lastMove = 0;
				this.attractDelay -= 1;
				this.weightCache = null;

			} else {
				// Handle Collision
				this.collision(obj);
				this.lastMove += 1;
			}

			if (this.isDead() || this.isInfertile() || this.isStagnant()) {
				this.kill();
			}
		},

		attract: function() {
			var weights = [1, 1, 1, 1, 1, 1, 1, 1];
			var agent = this;
			var nearest = width;
			var match = false;

			for (var i = 0, l = attractors.length; i < l; i++) {
				var attractor = attractors[i];
				if (attractor.color === agent.color) {
					var dist_agent = dist(agent.x, agent.y, attractor.x, attractor.y);
					if (dist_agent < ATTRACTOR_RADIUS) {
						var diffX = attractor.x - agent.x;
						var diffY = attractor.y - agent.y;
						var weight = ATTRACTOR_RADIUS * (1 / attractor.strength) *
							attractor.weight();
						var xWeight = (ATTRACTOR_RADIUS - diffX) / weight;
						var yWeight = (ATTRACTOR_RADIUS - diffY) / weight;

						if (diffX > 0) {
							weights[2] += xWeight;
							weights[4] += xWeight;
							weights[7] += xWeight;
						} else if (diffX < 0) {
							weights[0] += xWeight;
							weights[3] += xWeight;
							weights[5] += xWeight;
						}

						if (diffY > 0) {
							weights[5] += yWeight;
							weights[6] += yWeight;
							weights[7] += yWeight;
						} else if (diffY < 0) {
							weights[0] += yWeight;
							weights[1] += yWeight;
							weights[2] += yWeight;
						}

						match = true;
					} else {
						nearest = Math.min(nearest, dist_agent);
					}
				}
			}

			if (!match) {
				this.attractDelay = nearest - (ATTRACTOR_RADIUS / 2);
				return directions[Math.floor(Math.random() * directions.length)];
			}

			this.weightCache = weights;

			return this.getDirOnWeight(weights);
		},

		getDirOnWeight: function(weights) {
			var totalWeight = 0;

			for (var i = 0, l = weights.length; i < l; i++) {
				totalWeight += weights[i];
			}

			var cutoff = random(totalWeight);
			var sumWeight = 0;
			var dir = 0;

			for (var i = 0, l = weights.length; i < l; i++) {
				sumWeight += weights[i];

				if (cutoff < sumWeight) {
					dir = i;
					break;
				}
			}

			return directions[dir];
		},

		collision: function(other) {
			//console.log("Collision", other);
			if (other.color === this.color && other instanceof Agent &&
					!this.isChild() && !other.isChild()) {
				// Breed!
				if (random(1) < BREED) {
					this.breed();
				}
			}
		},

		breed: function() {
			this.lastBreed = 0;
			var dir = directions[Math.floor(Math.random() * directions.length)];
			var childX = this.x + (dir.x * this.width);
			var childY = this.y + (dir.y * this.height);
			new Agent(this.color, childX, childY);
		},

		draw: function() {
			if (this.isChild()) {
				set(this.x, this.y, this.color);
			} else if (this.dead) {
				deadPixels.set(this.x, this.y, this.color);
			} else {
				set(this.x, this.y, this.color);
			}

			this.age += 1;
			this.lastBreed += 1;
		}
	};

	var Attractor = function(color, x, y, strength) {
		this.color = color;
		this.x = x;
		this.y = y;
		this.strength = strength;
		this.age = 0;

		if (!atGrid(this)) {
			addGrid(this);
			attractors.push(this);
		}
	};

	Attractor.prototype = {
		lastFrame: -1,
		_weight: 1,
		width: 4,
		height: 4,

		isDead: function() {
			return ATTRACTOR_DEATH_AGE > 0 && this.age > ATTRACTOR_DEATH_AGE;
		},

		kill: function() {
			removeGrid(this);

			// Remove agent from the list
			var pos = attractors.indexOf(this);
			attractors.splice(pos, 1);
		},

		weight: function() {
			if (this.lastFrame < frameCount) {
				this._weight = ATTRACTOR_DEATH_AGE <= 0 ?
								1 :
								((ATTRACTOR_DEATH_AGE - this.age) / ATTRACTOR_DEATH_AGE);
				this.lastFrame = frameCount;
			}
			return this._weight;
		},

		draw: function() {
			if (this.isDead()) {
				this.kill();
				return;
			}

			this.age += 1;
			if (this.strength == ATTRACT) {
				stroke(0, 0, 0, 42);
			} else {
				stroke(255, 0, 0, 42);
			}
			fill(this.color, 42 * this.weight());
			ellipse(this.x, this.y, ATTRACTOR_RADIUS * 2, ATTRACTOR_RADIUS * 2);
			fill(this.color, 128 * this.weight());
			ellipse(this.x, this.y, this.width, this.height);
		},
	};

	size(d, d);

	loadPixels();

	var deadPixels = createGraphics(width, height);
	deadPixels.loadPixels();
	new Attractor(color(0, 0, 0), 100, 100, ATTRACT);
	new Attractor(color(0, 0, 0), 20, 20, ATTRACT);
	new Attractor(color(0, 0, 0), 170, 150, ATTRACT);

	// new Attractor(color(0, 0, 0), 100, 80, REPEL);

	initAgents = function() {
		for (var i = 0; i < d; i++) {
			for (var j = 0; j < d; j++) {
				if (random(1) < INITIAL_AGENTS) {
					new Agent(color(0, 0, 0), i, j);

				}
			}
		}
	}
	initAgents();

	compareImage = function() {
		if (!(frameCount % 120) == 0) {
			return;
		}
		var n = d * d;
		var score = 0;
		for (var i = 0; i < d; i++) {
			for (var j = 0; j < d; j++) {
				var k = i + j * d;
				var srcPixel = red(imageData[k]);
				var hit = atPixel(i, j);
				if (!hit && srcPixel == 255) {
					score++;
				} else if (hit && red(hit.color) == srcPixel) {
					score++;
				}
			}
		}
		scoreSpan.innerHTML = (100 * score/n).toFixed(1) + "%";

	},
	draw = function() {
		background(255, 255, 255);
		compareImage();
		if (DRAW_ATTRACTORS) {
			for (var i = 0, l = attractors.length; i < l; i++) {
				attractors[i].draw();
			}
		}

		for (var i = 0, l = agents.length; i < l; i++) {
			var agent = agents[i];
			if (agent) {
				//if (agent.lastMove % 3 === 0) {
					agent.move();
				//} else {
				//	agent.lastMove += 1;
				//}

				agent.draw();
			}
		}

		if (agents.length) {
			updatePixels();
		}

		deadPixels.updatePixels();
		image(deadPixels, 0, 0);
	};

	mousePressed = function() {
		new Attractor(color(0, 0, 0), mouseX, mouseY, ATTRACTOR_MODE);
	};
	keyPressed = function() {
		if (key == 120) {
			if (ATTRACTOR_MODE == REPEL) {
				ATTRACTOR_MODE = ATTRACT;
			} else {
				ATTRACTOR_MODE = REPEL;
			}
		}
	}

	sketch.loop();
}
};
</script>