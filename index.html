
<style type="text/css">
	canvas {
		outline: none;
		border: 2px solid #000;
	}
</style>
<canvas id="canvas" width="400" height="400"></canvas>
<script src="processing-1.4.1.js"></script>
<script>
var BREED = 0.05;
var ATTRACTOR_RADIUS = 80;
var ATTRACT = 0.1;
var REPEL = 0.05;
var CHILD_AGE = 100;
var DEATH_AGE = 0;
var ATTRACTOR_DEATH_AGE = 0;
var LAST_BREED = 3000;
var LAST_MOVE = 50;

window.onload = function() {
	var sketch = new Processing("canvas");

	with(sketch) {

	var directions = [
		{ x: -1, y: -1 },
		{ x: 0, y: -1 },
		{ x: 1, y: -1 },
		
		{ x: -1, y: 0 },
		//{ x: 0, y: 0 },
		{ x: 1, y: 0 },
		
		{ x: -1, y: 1 },
		{ x: 0, y: 1 },
		{ x: 1, y: 1 }
	];

	var grid = [];
	var agents = [];
	var attractors = [];

	var atGrid = function(obj) {
		var startX = obj.x - floor(obj.width / 2);
		var endX = obj.x + floor(obj.width / 2);
		var startY = obj.y - floor(obj.height / 2);
		var endY = obj.y + floor(obj.height / 2);
		
		for (var x = startX; x <= endX; x++) {
			for (var y = startY; y <= endY; y++) {
				var pos = (x * width) + y;
				if (grid[pos] && grid[pos] !== obj) {
					return grid[pos];
				}
			}
		}

		return false;
	};

	var addGrid = function(obj) {
		var startX = obj.x - floor(obj.width / 2);
		var endX = obj.x + floor(obj.width / 2);
		var startY = obj.y - floor(obj.height / 2);
		var endY = obj.y + floor(obj.height / 2);
		
		for (var x = startX; x <= endX; x++) {
			for (var y = startY; y <= endY; y++) {
				var pos = (x * width) + y;
				grid[pos] = obj;
			}
		}
	};

	var removeGrid = function(obj, x, y) {
		x = x || obj.x;
		y = y || obj.y
		var startX = x - floor(obj.width / 2);
		var endX = x + floor(obj.width / 2);
		var startY = y - floor(obj.height / 2);
		var endY = y + floor(obj.height / 2)
		
		for (var x = startX; x <= endX; x++) {
			for (var y = startY; y <= endY; y++) {
				var pos = (x * width) + y;
				if (grid[pos] === obj) {
					grid[pos] = null;
				}
			}
		}
	};

	var Agent = function(color, x, y) {
		this.color = color;
		this.x = x;
		this.y = y;
		this.age = 0;
		this.lastBreed = 0;
		this.lastMove = 0;
		
		if (!atGrid(this)) {
			addGrid(this);
			agents.push(this);
		}
	};

	Agent.prototype = {
		width: 2,
		height: 2,

		isChild: function() {
			return this.age < CHILD_AGE;
		},

		isDead: function() {
			return DEATH_AGE > 0 && this.age > DEATH_AGE;
		},

		isInfertile: function() {
			return LAST_BREED > 0 && this.lastBreed > LAST_BREED;
		},

		isStagnant: function() {
			return LAST_MOVE > 0 && this.lastMove > LAST_MOVE;
		},

		kill: function() {
			removeGrid(this);

			// Remove agent from the list
			var pos = agents.indexOf(this);
			agents.splice(pos, 1);
		},

		move: function() {
			var originalX = this.x;
			var originalY = this.y;

			var dir = this.attract();

			this.x += dir.x * floor(this.width / 2);
			this.y += dir.y * floor(this.height / 2);

			if (this.x < 0) {
				this.x += width;
			} else if (this.x > width) {
				this.x -= width;
			}

			if (this.y < 0) {
				this.y += height;
			} else if (this.y > height) {
				this.y -= height;
			}

			var obj = atGrid(this);

			if (!obj) {
				removeGrid(this, originalX, originalY);
				addGrid(this);
				this.lastMove = 0;

			} else {
				// Handle Collision
				this.collision(obj);
				this.x = originalX;
				this.y = originalY;
				this.lastMove += 1;
			}
		},

		attract: function() {
			var weights = [1, 1, 1, 1, 1, 1, 1, 1];
			var agent = this;

			attractors.forEach(function(attractor) {
				if (attractor.color === agent.color) {
					var dist_agent = dist(agent.x, agent.y, attractor.x, attractor.y);
					if (dist_agent < ATTRACTOR_RADIUS) {
						var diffX = attractor.x - agent.x;
						var diffY = attractor.y - agent.y;
						var weight = ATTRACTOR_RADIUS * (1 / ATTRACT);
						var xWeight = (ATTRACTOR_RADIUS - diffX) / weight;
						var yWeight = (ATTRACTOR_RADIUS - diffY) / weight;
						
						if (diffX > 0) {
							weights[2] += xWeight;
							weights[4] += xWeight;
							weights[7] += xWeight;
						} else if (diffX < 0) {
							weights[0] += xWeight;
							weights[3] += xWeight;
							weights[5] += xWeight;
						}
						
						if (diffY > 0) {
							weights[5] += yWeight;
							weights[6] += yWeight;
							weights[7] += yWeight;
						} else if (diffY < 0) {
							weights[0] += yWeight;
							weights[1] += yWeight;
							weights[2] += yWeight;
						}
					}
				}
			});

			var totalWeight = 0;

			weights.forEach(function(weight) {
				totalWeight += weight;
			});

			var cutoff = random(totalWeight);
			var sumWeight = 0;
			var dir;
			
			for (var i = 0; i < weights.length; i++) {
				sumWeight += weights[i];
				
				if (cutoff < sumWeight) {
					dir = i;
					break;
				}
			}
			
			return directions[dir];
		},

		collision: function(other) {
			//console.log("Collision", other);
			if (other.color === this.color && other instanceof Agent &&
					!this.isChild() && !other.isChild()) {
				// Breed!
				if (random(1) < BREED) {
					this.breed();
				}
			}
		},

		breed: function() {
			this.lastBreed = 0;
			var dir = directions[floor(random(directions.length))];
			var childX = this.x + (dir.x * this.width);
			var childY = this.y + (dir.y * this.height);
			new Agent(this.color, childX, childY);
		},

		draw: function() {
			if (this.isDead() || this.isInfertile() || this.isStagnant()) {
				this.kill();
				return;
			}

			noStroke();
			if (this.isChild()) {
				fill(this.color, 128);
			} else {
				fill(this.color);
			}
			ellipse(this.x, this.y, this.width, this.height);

			this.age += 1;
			this.lastBreed += 1;
		}
	};

	var Attractor = function(color, x, y, strength) {
		this.color = color;
		this.x = x;
		this.y = y;
		this.strength = strength;
		this.age = 0;
		
		if (!atGrid(this)) {
			addGrid(this);
			attractors.push(this);
		}
	};

	Attractor.prototype = {
		width: 8,
		height: 8,

		isDead: function() {
			return ATTRACTOR_DEATH_AGE > 0 && this.age > ATTRACTOR_DEATH_AGE;
		},

		kill: function() {
			removeGrid(this);

			// Remove agent from the list
			var pos = attractors.indexOf(this);
			attractors.splice(pos, 1);
		},

		draw: function() {
			if (this.isDead()) {
				this.kill();
				return;
			}

			this.age += 1;

			stroke(0, 0, 0, 42);
			fill(this.color, 42);
			ellipse(this.x, this.y, ATTRACTOR_RADIUS, ATTRACTOR_RADIUS);
			fill(this.color, 128);
			ellipse(this.x, this.y, this.width, this.height);
		},
	};

	size(400, 400);

	new Attractor(color(0, 0, 0), 200, 200);
	new Attractor(color(0, 0, 0), 200, 160);

	draw = function() {
		background(255, 255, 255);

		attractors.forEach(function(attractor) {
			attractor.draw();
		});

		agents.forEach(function(agent) {
			agent.move();
			agent.draw();
		});
	};

	mousePressed = function() {
		new Agent(color(0, 0, 0), mouseX, mouseY);
	};

	sketch.loop();
}
};
</script>