
<style type="text/css">
	canvas {
		outline: none;
		border: 2px solid #000;
	}
</style>
<canvas id="canvas" width="400" height="400"></canvas>
<script src="processing-1.4.1.js"></script>
<script>
window.onload = function() {
	var sketch = new Processing("canvas");

	with(sketch) {

	var BREED = 0.05;
	var ATTRACTOR_RADIUS = 80;
	var ATTRACT = 0.1;
	var REPEL = 0.05;

	var directions = [
		{ x: -1, y: -1 },
		{ x: 0, y: -1 },
		{ x: 1, y: -1 },
		
		{ x: -1, y: 0 },
		//{ x: 0, y: 0 },
		{ x: 1, y: 0 },
		
		{ x: -1, y: 1 },
		{ x: 0, y: 1 },
		{ x: 1, y: 1 }
	];

	var grid = [];

	var atGrid = function(obj) {
		var startX = obj.x - floor(obj.width / 2);
		var endX = obj.x + floor(obj.width / 2);
		var startY = obj.y - floor(obj.height / 2);
		var endY = obj.y + floor(obj.height / 2);
		
		for (var x = startX; x <= endX; x++) {
			for (var y = startY; y <= endY; y++) {
				var pos = (x * width) + y;
				if (grid[pos] && grid[pos] !== obj) {
					return grid[pos];
				}
			}
		}

		return false;
	};

	var addGrid = function(obj) {
		var startX = obj.x - floor(obj.width / 2);
		var endX = obj.x + floor(obj.width / 2);
		var startY = obj.y - floor(obj.height / 2);
		var endY = obj.y + floor(obj.height / 2);
		
		for (var x = startX; x <= endX; x++) {
			for (var y = startY; y <= endY; y++) {
				var pos = (x * width) + y;
				grid[pos] = obj;
			}
		}
	};

	var removeGrid = function(obj, x, y) {
		x = x || obj.x;
		y = y || obj.y
		var startX = x - floor(obj.width / 2);
		var endX = x + floor(obj.width / 2);
		var startY = y - floor(obj.height / 2);
		var endY = y + floor(obj.height / 2)
		
		for (var x = startX; x <= endX; x++) {
			for (var y = startY; y <= endY; y++) {
				var pos = (x * width) + y;
				if (grid[pos] === obj) {
					grid[pos] = null;
				}
			}
		}
	};

	var agents = [];
	var attractors = [];

	var addAgent = function(color, x, y) {
		var agent = new Agent(color, x, y);
		if (!atGrid(agent)) {
			addGrid(agent);
			agents.push(agent);
		}
	};

	var Agent = function(color, x, y) {
		this.color = color;
		this.x = x;
		this.y = y;
	};

	Agent.prototype = {
		width: 2,
		height: 2,

		move: function() {
			// Add in attactor weights

			var originalX = this.x;
			var originalY = this.y;

			var dir = this.attract();

			this.x += dir.x * floor(this.width / 2);
			this.y += dir.y * floor(this.height / 2);

			if (this.x < 0) {
				this.x += width;
			} else if (this.x > width) {
				this.x -= width;
			}

			if (this.y < 0) {
				this.y += height;
			} else if (this.y > height) {
				this.y -= height;
			}

			var obj = atGrid(this);

			if (!obj) {
				removeGrid(this, originalX, originalY);
				addGrid(this);

			} else {
				// Handle Collision
				this.collision(obj);
				this.x = originalX;
				this.y = originalY;
			}
		},

		attract: function() {
			var weights = [1, 1, 1, 1, 1, 1, 1, 1];
			var agent = this;

			attractors.forEach(function(attractor) {
				if (attractor.color === agent.color) {
					var dist_agent = dist(agent.x, agent.y, attractor.x, attractor.y);
					if (dist_agent < ATTRACTOR_RADIUS) {
						var diffX = attractor.x - agent.x;
						var diffY = attractor.y - agent.y;
						var weight = ATTRACTOR_RADIUS * (1 / ATTRACT);
						var xWeight = (ATTRACTOR_RADIUS - diffX) / weight;
						var yWeight = (ATTRACTOR_RADIUS - diffY) / weight;
						
						if (diffX > 0) {
							weights[2] += xWeight;
							weights[4] += xWeight;
							weights[7] += xWeight;
						} else if (diffX < 0) {
							weights[0] += xWeight;
							weights[3] += xWeight;
							weights[5] += xWeight;
						}
						
						if (diffY > 0) {
							weights[5] += yWeight;
							weights[6] += yWeight;
							weights[7] += yWeight;
						} else if (diffY < 0) {
							weights[0] += yWeight;
							weights[1] += yWeight;
							weights[2] += yWeight;
						}
					}
				}
			});

			var totalWeight = 0;

			weights.forEach(function(weight) {
				totalWeight += weight;
			});

			var cutoff = random(totalWeight);
			var sumWeight = 0;
			var dir;
			
			for (var i = 0; i < weights.length; i++) {
				sumWeight += weights[i];
				
				if (cutoff < sumWeight) {
					dir = i;
					break;
				}
			}
			
			return directions[dir];
		},

		collision: function(other) {
			//console.log("Collision", other);
			if (other.color === this.color && other instanceof Agent) {
				// Breed!
				if (random(1) < BREED) {
					this.breed();
				}
			}
		},

		breed: function() {
			var dir = directions[floor(random(directions.length))];
			var childX = this.x + (dir.x * this.width);
			var childY = this.y + (dir.y * this.height);
			addAgent(color(255, 0, 0), childX, childY);
		},

		draw: function() {
			noStroke();
			fill(this.color);
			ellipse(this.x, this.y, this.width, this.height);
		}
	};

	var addAttractor = function(color, x, y, strength) {
		var attractor = new Attractor(color, x, y, strength);
		if (!atGrid(attractor)) {
			addGrid(attractor);
			attractors.push(attractor);
		}
	};

	var Attractor = function(color, x, y, strength) {
		this.color = color;
		this.x = x;
		this.y = y;
		this.strength = strength;
	};

	Attractor.prototype = {
		width: 8,
		height: 8,

		draw: function() {
			stroke(0, 0, 0);
			fill(this.color, 0.1);
			ellipse(this.x, this.y, ATTRACTOR_RADIUS, ATTRACTOR_RADIUS);
			fill(this.color);
			ellipse(this.x, this.y, this.width, this.height);
		},
	};

	size(400, 400);

	addAttractor(color(0, 0, 0), 200, 200);
	addAttractor(color(0, 0, 0), 200, 160);

	draw = function() {
		background(255, 255, 255);

		attractors.forEach(function(attractor) {
			attractor.draw();
		});

		agents.forEach(function(agent) {
			agent.move();
			agent.draw();
		});
	};

	mousePressed = function() {
		addAgent(color(0, 0, 0), mouseX, mouseY);
	};

	sketch.loop();
}
};
</script>